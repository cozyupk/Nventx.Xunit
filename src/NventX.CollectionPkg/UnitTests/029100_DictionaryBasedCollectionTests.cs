using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading.Tasks;
using NventX.CollectionPkg.Impl;
using Xunit;

namespace NventX.CollectionPkg.UnitTest
{
    /// ▽▽ Framework for tests that use a dictionary-based collection. ▽▽
    public abstract class TestsBase
    {
        protected static ConcurrentDictionary<string, Task> Tasks { get; } = new();

        protected static object CasesLock { get; } = new();
        private static bool IsCasesCommitted { get; set; } = false;

        private static void RegisterTaskWithLabel(string label, Task task)
        {
            ArgumentNullException.ThrowIfNull(label);
            ArgumentNullException.ThrowIfNull(task);
            Console.WriteLine("OK");
            if (Tasks.TryAdd(label, task) == false)
            {
                // throw new InvalidOperationException($"Test case '{label}' already exists in the collection. Please use a unique test case name.");
            } else
            {
                // throw new InvalidOperationException($"Test case '{label}' registered!");
                Console.WriteLine($"Test case '{label}' registered!");
            }
        }

        private static void CommitCasesBase(Action action)
        {
            lock (CasesLock)
            {
                /*
                if (IsCasesCommitted)
                {
                    // Silently ignore if cases are already committed.
                    return;
                }
                */
                action?.Invoke();
                IsCasesCommitted = true;
            }
        }

        // Generated by GPT. Starting strong!
        public abstract class TheoryDataWithTasks<T1> : TheoryData<string, T1>
        {
            protected void AddWithAction(string label, T1 p1, Task task)
            {
                RegisterTaskWithLabel(label, task);
                Add(label, p1);
            }

            protected void CommitCases(Action action)
            {
                CommitCasesBase(action);
            }
        }

        // Still alive. T2 is okay.
        public abstract class TheoryDataWithTasks<T1, T2> : TheoryData<string, T1, T2>
        {
            protected void AddWithAction(string label, T1 p1, T2 p2, Task task)
            {
                RegisterTaskWithLabel(label, task);
                Add(label, p1, p2);
            }

            protected void CommitCases(Action action)
            {
                CommitCasesBase(action);
            }
        }

        // Slightly dizzy, but hanging in. T3 coming in.
        public abstract class TheoryDataWithTasks<T1, T2, T3> : TheoryData<string, T1, T2, T3>
        {
            protected void AddWithAction(string label, T1 p1, T2 p2, T3 p3, Task task)
            {
                RegisterTaskWithLabel(label, task);
                Add(label, p1, p2, p3);
            }

            protected void CommitCases(Action action)
            {
                CommitCasesBase(action);
            }
        }

        // Determined. T4 is here.
        public abstract class TheoryDataWithTasks<T1, T2, T3, T4> : TheoryData<string, T1, T2, T3, T4>
        {
            protected void AddWithAction(string label, T1 p1, T2 p2, T3 p3, T4 p4, Task task)
            {
                RegisterTaskWithLabel(label, task);
                Add(label, p1, p2, p3, p4);
            }

            protected void CommitCases(Action action)
            {
                CommitCasesBase(action);
            }
        }

        // Still going. GPT hasn't collapsed yet. T5.
        public abstract class TheoryDataWithTasks<T1, T2, T3, T4, T5> : TheoryData<string, T1, T2, T3, T4, T5>
        {
            protected void AddWithAction(string label, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, Task task)
            {
                RegisterTaskWithLabel(label, task);
                Add(label, p1, p2, p3, p4, p5);
            }

            protected void CommitCases(Action action)
            {
                CommitCasesBase(action);
            }
        }

        // You asked for it. Let's go.
        public abstract class TheoryDataWithTasks<T1, T2, T3, T4, T5, T6> : TheoryData<string, T1, T2, T3, T4, T5, T6>
        {
            protected void AddWithAction(string label, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, Task task)
            {
                RegisterTaskWithLabel(label, task);
                Add(label, p1, p2, p3, p4, p5, p6);
            }

            protected void CommitCases(Action action)
            {
                CommitCasesBase(action);
            }
        }

        // Okay this is getting serious.
        public abstract class TheoryDataWithTasks<T1, T2, T3, T4, T5, T6, T7> : TheoryData<string, T1, T2, T3, T4, T5, T6, T7>
        {
            protected void AddWithAction(string label, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, Task task)
            {
                RegisterTaskWithLabel(label, task);
                Add(label, p1, p2, p3, p4, p5, p6, p7);
            }

            protected void CommitCases(Action action)
            {
                CommitCasesBase(action);
            }
        }

        // GPT is now sweating.
        public abstract class TheoryDataWithTasks<T1, T2, T3, T4, T5, T6, T7, T8> : TheoryData<string, T1, T2, T3, T4, T5, T6, T7, T8>
        {
            protected void AddWithAction(string label, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, Task task)
            {
                RegisterTaskWithLabel(label, task);
                Add(label, p1, p2, p3, p4, p5, p6, p7, p8);
            }

            protected void CommitCases(Action action)
            {
                CommitCasesBase(action);
            }
        }

        // You still reading this? Respect.
        public abstract class TheoryDataWithTasks<T1, T2, T3, T4, T5, T6, T7, T8, T9> : TheoryData<string, T1, T2, T3, T4, T5, T6, T7, T8, T9>
        {
            protected void AddWithAction(string label, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, Task task)
            {
                RegisterTaskWithLabel(label, task);
                Add(label, p1, p2, p3, p4, p5, p6, p7, p8, p9);
            }

            protected void CommitCases(Action action)
            {
                CommitCasesBase(action);
            }
        }
    }
    /// △△ Framework for tests that use a dictionary-based collection. △△

    public class DictionaryBasedCollectionTests : TestsBase
    {
        public class ExceptionCases : TheoryDataWithTasks<Type, string, Dictionary<string, string>>
        {
             public ExceptionCases()
            {
                CommitCases(() =>
                {
                    AddWithAction(
                        "ConstructorInvokedWithNullFuncToCreateBaseDictionary",
                        typeof(ArgumentNullException),
                        "hoge",
                        Task.Run(() =>
                        {
                            lock (CasesLock)
                            {
                                _ = new DictionaryBasedCollection<string>(null!);
                            }
                        })
                    );
                    /*
                    AddWithAction(
                        "ConstructorInvokedWithFuncReturningNullDictionary",
                        typeof(ArgumentNullException),
                        "hoge",
                        Task.Run(() =>
                        {
                            lock (CasesLock)
                            {
                                _ = new DictionaryBasedCollection<string>(() => null!);
                            }
                        })
                    );
                    */
                });
            }
        }

        [ExceptionCase(typeof(ArgumentNullException)), "funcToCreateBasedCollection is null."]
        async static void ConstructorInvokedWithNullFuncToCreateBaseDictionary()
        {
            await Task.Run(() =>
            {
                lock (CasesLock)
                {
                    _ = new DictionaryBasedCollection<string>(null!);
                }
            });
        }

        [Theory]
        [ClassData(typeof(ExceptionCases))]
        public async Task ExceptionCases_Throws_ExpectedException(string label, Type expectedExceptionType, string expectedMessage)
        {
            // Arrange &  Act
            var ex = await Record.ExceptionAsync(() => Tasks[label]);

            // Assert
            Assert.NotNull(ex);
            Assert.IsType(expectedExceptionType, ex);
            Assert.Contains(expectedMessage, ex.Message);
        }
    }
}
