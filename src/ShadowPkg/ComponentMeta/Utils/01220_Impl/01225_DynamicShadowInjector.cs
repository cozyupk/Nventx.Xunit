using System;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Reflection;
using Cozyupk.HelloShadowDI.ShadowPkg.ComponentMeta.Attributes;
using Cozyupk.HelloShadowDI.ShadowPkg.ComponentMeta.Utils.Contracts;
using Unity;
using Unity.Lifetime;

namespace Cozyupk.HelloShadowDI.ShadowPkg.ComponentMeta.Utils.Impl
{
    /// <summary>
    /// A utility class for dynamically injecting dependencies into a Unity container
    /// by scanning assemblies for types marked with the ShadowInjectableAttribute.
    /// </summary>
    public class DynamicShadowInjector
    {
        /// <summary>
        /// Gets the root path of the assemblies to be scanned for dependency injection.
        /// </summary>
        public string RootAssemblyPath { get; }

        /// <summary>
        /// Provides a diagnostic notifier for emitting diagnostic messages.
        /// </summary>
        IShadowDiagnosticNotifierProvider DiagnosticNotifierProvider { get; }

        /// <summary>
        /// Provides a diagnostic notifier for emitting diagnostic messages.
        /// This is used to notify observers about diagnostic events or messages
        /// during the dependency injection process.
        /// </summary>
        IShadowDiagnosticNotifier DiagnosticNotifier { get; }

        /// <summary>
        /// Gets the default injection scope to be used when no specific scope is defined.
        /// </summary>
        public InjectionScope DefaultScope { get; }

        /// <summary>
        /// Analyzes assembly dependencies and generates a dependency graph.
        /// </summary>
        private AssemblyDependencyAnalyzer DependencyAnalyzer { get; } = new AssemblyDependencyAnalyzer();

        /// <summary>
        /// A static lock object used to ensure thread-safe operations when registering types
        /// into the Unity container. This prevents race conditions during concurrent access.
        /// </summary>
        private static object RegistrationLock { get; } = new object();

        /// <summary>
        /// A thread-safe cache for storing loaded assemblies, ensuring that the same assembly
        /// is not loaded multiple times. This improves performance and avoids potential conflicts
        /// caused by redundant loads.
        /// </summary>
        private static ConcurrentDictionary<string, Assembly?> AssemblyCache { get; } = new ConcurrentDictionary<string, Assembly?>();

        /// <summary>
        /// Initializes a new instance of the <see cref="DynamicShadowInjector"/> class.
        /// The constructor is marked as <c>protected internal</c> to restrict instantiation
        /// to the same assembly or derived classes, enforcing controlled construction via the corresponding builder.
        /// </summary>
        /// <param name="rootAssemblyPath">The root directory path containing the assemblies to scan.</param>
        /// <param name="diagnosticNotifierProvider">DiagnosticNotifier to be used for notifying diagnostics messages.</param>
        /// <param name="defaultScope">The default injection scope to use if not specified in the attribute.</param>
        protected internal DynamicShadowInjector(
            string rootAssemblyPath,
            IShadowDiagnosticNotifierProvider diagnosticNotifierProvider,
            InjectionScope defaultScope = InjectionScope.Transient
        ) {
            // Set the properties for the instance.
            RootAssemblyPath = rootAssemblyPath;
            DiagnosticNotifierProvider = diagnosticNotifierProvider;
            DefaultScope = defaultScope;

            // Create a new instance of the DiagnosticNotifier using the provided diagnostic notifier provider.
            DiagnosticNotifier = diagnosticNotifierProvider.CreateDiagnosticNotifier("ShadowDI");
        }

        /// <summary>
        /// Conditionally emits a diagnostic message only if observers are present.
        /// The message content is generated by invoking the supplied delegate,
        /// avoiding unnecessary string construction when no observers are registered.
        /// </summary>
        /// <param name="messageFactory">A delegate that appends message content to a list of strings.</param>
        /// <param name="level">The severity level of the diagnostic message. Defaults to <see cref="ShadowDiagnosticLevel.Info"/>.</param>
        protected internal virtual void OnBuildCompleted()
        {
            // This method can be overridden in derived classes to perform additional actions after the build is completed.

            // Notify observers about the successful construction of the DynamicShadowInjector.
            DiagnosticNotifier.Notify($"DynamicShadowInjector successfully built.", ShadowDiagnosticLevel.Info);

            // Notify observers with a dependency graph if any observers are present.
            DiagnosticNotifier.NotifyIfObserved(
                () => DependencyAnalyzer.GetDependencyGraph(),
                ShadowDiagnosticLevel.Trace
            );
        }

        /// <summary>
        /// Loads an assembly from the specified path using a thread-safe cache mechanism.
        /// This ensures that the same assembly is not loaded multiple times, improving performance
        /// and avoiding potential conflicts caused by redundant loads.
        /// </summary>
        /// <param name="path">The file path of the assembly to load.</param>
        /// <returns>
        /// The loaded <see cref="Assembly"/> object if successful; otherwise, <c>null</c> if the load fails.
        /// </returns>
        private Assembly? LoadAssemblyWithThreadSafeCache(string path)
        {
            // Use a thread-safe dictionary to cache loaded assemblies.
            return AssemblyCache.GetOrAdd(path, p =>
            {
                try
                {
                    // Attempt to load the assembly from the specified path.
                    return Assembly.LoadFrom(p);
                }
                catch (Exception ex)
                {
                    // Notify diagnostic observers about the failure to load the assembly.
                    DiagnosticNotifier.Notify(
                        $"[ShadowDI] Failed to load assembly: {p} - {ex.Message}",
                        ShadowDiagnosticLevel.Warning
                    );
                    // Return null to indicate the failure.
                    return null;
                }
            });
        }

        /// <summary>
        /// Ensures thread-safe registration of a service type and its implementation type
        /// into the Unity container with the specified injection scope.
        /// </summary>
        /// <param name="container">The Unity container to register the types into.</param>
        /// <param name="serviceType">The interface or base type to register.</param>
        /// <param name="implementationType">The concrete type implementing the service type.</param>
        /// <param name="scope">
        /// The injection scope to use:
        /// <list type="bullet">
        ///   <item><description><see cref="InjectionScope.Singleton"/> – one shared instance</description></item>
        ///   <item><description><see cref="InjectionScope.Scoped"/> – one instance per logical scope</description></item>
        ///   <item><description><see cref="InjectionScope.Transient"/> – new instance per request</description></item>
        /// </list>
        /// </param>
        private void RegisterTypeThreadSafely(IUnityContainer container, Type serviceType, Type implementationType, InjectionScope scope)
        {
            // Lock to ensure thread-safe registration in the Unity container.
            lock (RegistrationLock)
            {
                switch (scope)
                {
                    case InjectionScope.Singleton:
                        // Register a single instance shared across the application.
                        container.RegisterSingleton(serviceType, implementationType);
                        break;

                    case InjectionScope.Scoped:
                        // Register a new instance for each scope using HierarchicalLifetimeManager.
                        container.RegisterType(serviceType, implementationType, new HierarchicalLifetimeManager());
                        break;

                    case InjectionScope.Transient:
                        // Register a new instance every time it is requested.
                        container.RegisterType(serviceType, implementationType);
                        break;

                    default:
                        // Handle unsupported or unspecified injection scopes.
                        throw new ArgumentOutOfRangeException(nameof(scope), $"Unsupported injection scope: {scope}");
                }
            }
        }

        /// <summary>
        /// Scans the specified assemblies for types marked with ShadowInjectableAttribute
        /// and registers them into the provided Unity container.
        /// </summary>
        /// <param name="container">The Unity container to register the dependencies into.</param>
        public void Inject(IUnityContainer container)
        {
            // Inject DiagnosticNotifierProvider into the container.
            container.RegisterInstance<IShadowDiagnosticNotifierProvider>(DiagnosticNotifierProvider);

            // Retrieve all .dll files from the specified root assembly path, including subdirectories.
            var assemblies = Directory.GetFiles(RootAssemblyPath, "*.dll", SearchOption.AllDirectories)
                                     .Select(path =>
                                     {
                                         // Use the thread-safe cache mechanism to load assemblies.
                                         return LoadAssemblyWithThreadSafeCache(path);
                                     })
                                     // Filter out any null entries resulting from failed loads.
                                     .Where(a => a != null)!;

            foreach (var assembly in assemblies)
            {
                // Array to hold the types defined in the current assembly.
                Type[] types;

                // Skip processing if the assembly is null.
                if (assembly == null) continue;

                try
                {
                    // Attempt to retrieve all types from the assembly.
                    types = assembly.GetTypes();
                }
                catch (ReflectionTypeLoadException ex)
                {
                    // Handle cases where some types fail to load by filtering out null entries.
                    types = ex.Types.Where(t => t != null).ToArray()!;
                }

                // Flag to track if any types were successfully registered.
                bool isRegistered = false;

                // Iterate through all types in the assembly.
                foreach (var type in types)
                {
                    // Check if the type is marked with the ShadowInjectableAttribute.
                    var attr = type.GetCustomAttribute<ShadowInjectableAttribute>();
                    if (attr == null) continue;

                    // Retrieve the service type and injection scope from the attribute.
                    var serviceType = attr.ServiceType;
                    var scope = attr.Scope != InjectionScope.Unspecified ? attr.Scope : DefaultScope;

                    // Register the type in the Unity container based on the specified scope.
                    switch (scope)
                    {
                        case InjectionScope.Singleton:
                            RegisterTypeThreadSafely(container, serviceType, type, InjectionScope.Singleton);
                            break;

                        case InjectionScope.Scoped:
                            RegisterTypeThreadSafely(container, serviceType, type, InjectionScope.Scoped);
                            break;

                        case InjectionScope.Transient:
                            RegisterTypeThreadSafely(container, serviceType, type, InjectionScope.Transient);
                            break;

                        default:
                            // Log a warning if the scope is unsupported.
                            DiagnosticNotifier.Notify($"Unsupported scope: {scope} in {type.FullName}", ShadowDiagnosticLevel.Warning);
                            continue;
                    }

                    // Notify observers about the successful registration.
                    DiagnosticNotifier.Notify($"Registered: {serviceType.Name} → {type.FullName} ({scope})", ShadowDiagnosticLevel.Info);
                    isRegistered = true;
                }

                // If no types were registered, skip further processing for this assembly.
                if (!isRegistered)
                {
                    continue;
                }

                // Notify observers with a dependency graph if any observers are present.
                DiagnosticNotifier.NotifyIfObserved(
                    () => DependencyAnalyzer.GetDependencyGraph(assembly.FullName),
                    ShadowDiagnosticLevel.Trace
                );
            }
        }
    }
}