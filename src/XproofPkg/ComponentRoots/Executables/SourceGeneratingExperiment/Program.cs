using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text;
using Xunit;

namespace Xproof.SupportingXunit.Test
{
    public static class Program
    {
        public static void Main()
        {
            var generated = XProofGenerator.GenerateFrom(typeof(Assert));
            Console.WriteLine(generated);
        }
    }

    // ---------------------------------------------
    // Body of the xProof generator for xUnit's Assert class
    // ---------------------------------------------
    public static class XProofGenerator
    {
        private static string AvoidCollision(string? name)
        {
            if (name == null)
            {
                return "";
            }
            return "arg_" + name;
        }

        private static string FormatParameterDecl(ParameterInfo param)
        {
            var paramName = AvoidCollision(param.Name!);
            var allowNull = param.IsDefined(typeof(AllowNullAttribute), inherit: false) ? "[AllowNull] " : "";
            return $"{allowNull}{FormatType(param.ParameterType)} {paramName}";
        }

        private static bool IsNullable(ParameterInfo param)
        {
            if (param.IsDefined(typeof(AllowNullAttribute), inherit: false))
                return true;

            var attr = param.GetCustomAttributes()
                            .FirstOrDefault(a => a.GetType().FullName == "System.Runtime.CompilerServices.NullableAttribute");

            if (attr == null) return false;

            var field = attr.GetType().GetField("NullableFlags");
            if (field != null)
            {
                return field.GetValue(attr) is byte[] flags && flags.Length > 0 && flags[0] == 2;
            }

            // fallback: direct flag (non-generic)
            var prop = attr.GetType().GetProperty("NullableFlag");
            return prop?.GetValue(attr) is byte b && b == 2;
        }

        private static string FormatType(Type type)
        {
            if (type.IsArray)
            {
                // Recursively format array element type
                return FormatType(type.GetElementType()!) + "[]";
            }

            if (type.IsGenericType)
            {
                var typeDefName = type.Name[..type.Name.IndexOf('`')];
                var genericArgs = type.GetGenericArguments();
                var genericArgsFormatted = string.Join(", ", genericArgs.Select(FormatType));
                return $"{typeDefName}<{genericArgsFormatted}>";
            }

            if (type.IsByRef)
                return FormatType(type.GetElementType()!) + "&"; // Support ref/out parameters

            if (type.IsPointer)
                return FormatType(type.GetElementType()!) + "*"; // Support Ptr pointers

            return type.FullName ?? type.Name;
        }

        public static string GenerateFrom(Type assertType)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// Auto-generated by xProof Generator");
            sb.AppendLine("// Do not edit this file directly.");
            sb.AppendLine();
            sb.AppendLine("// This code wraps methods from xUnit's Assert class (Apache License, Version 2.0).");
            sb.AppendLine("// xUnit is maintained by the .NET Foundation and Contributors.");
            sb.AppendLine("// https://github.com/xunit/xunit");
            sb.AppendLine();
            sb.AppendLine("using System.Collections.Concurrent;");
            sb.AppendLine("using System.Collections.Immutable;");
            sb.AppendLine("using System.Collections.ObjectModel;");
            sb.AppendLine("using xProof.BaseProofLibrary.Proofs;");
            sb.AppendLine("using Xunit;");
            sb.AppendLine();
            sb.AppendLine("namespace xProof.SupportingXunit.Test {");
            sb.AppendLine("    public class AssertProof : XProof");
            sb.AppendLine("    {");

            var methods = assertType.GetMethods(BindingFlags.Static | BindingFlags.Public)
                .Where(m => m.ReturnType == typeof(void))
                .ToList();

            foreach (var m in methods)
            {
                // Skip obsolete methods
                var obsolete = m.GetCustomAttribute<ObsoleteAttribute>();
                if (obsolete is not null)
                {
                    continue;
                }

                // Skip methods using Span/ReadOnlySpan
                // TODO: Support Span/ReadOnlySpan
                var spanParameters
                    = m.GetParameters()
                       .Where(p => p.ParameterType.IsGenericType
                                    &&    (p.ParameterType.GetGenericTypeDefinition() == typeof(Span<>)
                                       || (p.ParameterType.GetGenericTypeDefinition() == typeof(ReadOnlySpan<>))));

                if (spanParameters.Any())
                {
                    continue;
                }

                // Support generic and non-generic methods
                if (m.IsGenericMethodDefinition)
                {
                    // For generic methods, we need to handle the generic type parameters
                    var genericArgs = m.GetGenericArguments();
                    var genericParams = string.Join(", ", genericArgs.Select(t => t.Name));
                    var genericDecl = $"<{genericParams}>";

                    var parameters = m.GetParameters();
                    var paramDecls = string.Join(", ",
                        m.GetParameters().Select(p => FormatParameterDecl(p))
                    );
                    HashSet<Type> notNullableTypes = [];
                    foreach (var p in parameters)
                    {
                        if (IsNullable(p))
                        {
                            continue;
                        }
                        notNullableTypes.Add(p.ParameterType);
                    }
                    var paramArgs = string.Join(", ", parameters.Select(p => AvoidCollision(p.Name)));

                    var genericConstraints = m.GetGenericArguments()
                            .Select(t =>
                                {
                                    var constraintParts = new List<string>();
                                    var isStruct = false;

                                    // Special constraints bit flags (Struct, Class, DefaultConstructor)
                                    var attrs = t.GenericParameterAttributes;

                                    if (attrs.HasFlag(GenericParameterAttributes.NotNullableValueTypeConstraint))
                                    {
                                        isStruct = true;
                                        constraintParts.Add("struct");
                                    }
                                    if (notNullableTypes.Contains(t))
                                    {
                                        constraintParts.Add("notnull");
                                    }

                                    // Interface and Type constraints
                                    foreach (var tc in t.GetGenericParameterConstraints())
                                    {
                                        var shouldOmmit = false;
                                        if (isStruct)
                                        {
                                            foreach (var tp in new[] { typeof(System.ValueType), typeof(System.IEquatable<>), typeof(System.IComparable<>) })
                                            {
                                                if (
                                                    (tc.IsGenericType && tc.GetGenericTypeDefinition() == tp)
                                                    || (tc == tp)
                                                   )
                                                {
                                                    shouldOmmit = true;
                                                    break;
                                                }
                                            }
                                        }
                                        if (shouldOmmit)
                                        {
                                            continue;
                                        }
                                        constraintParts.Add(FormatType(tc));
                                    }

                                    // Add where clause only if there are constraints
                                    return constraintParts.Count == 0
                                        ? ""
                                        : $"where {t.Name} : {string.Join(", ", constraintParts)}";
                                });

                    var whereClause = string.Join(" ", genericConstraints.Where(c => !string.IsNullOrWhiteSpace(c)));
                    sb.AppendLine($"        public void {m.Name}{genericDecl}({paramDecls})");
                    if (!string.IsNullOrWhiteSpace(whereClause))
                    {
                        sb.AppendLine($"        {whereClause}");
                    }
                    sb.AppendLine("        {");
                    sb.AppendLine($"            Probe(() => {assertType.Name}.{m.Name}{genericDecl}({paramArgs}));");
                }
                else
                {
                    // For non-generic methods, we can directly use the method name
                    var parameters = m.GetParameters();
                    var paramDecls = string.Join(", ",
                        m.GetParameters().Select(p => FormatParameterDecl(p))
                    );
                    var paramArgs = string.Join(", ", parameters.Select(p => AvoidCollision(p.Name)));

                    sb.AppendLine($"        public void {m.Name}({paramDecls})");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            Probe(() => {assertType.Name}.{m.Name}({paramArgs}));");
                }
                sb.AppendLine("        }");
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }
    }
}