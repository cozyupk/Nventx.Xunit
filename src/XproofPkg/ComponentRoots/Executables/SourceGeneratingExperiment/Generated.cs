// Auto-generated by xProof Generator
// Do not edit this file directly.

// This code wraps methods from xUnit's Assert class (Apache License, Version 2.0).
// xUnit is maintained by the .NET Foundation and Contributors.
// https://github.com/xunit/xunit

using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using Xproof.BaseProofLibrary.Proofs;
using Xunit;

namespace Xproof.SupportingXunit.Test
{
    public class AssertProof<TLabelAxes> : DefaultProof<TLabelAxes>
    {
        public void All<T>(IAsyncEnumerable<T> arg_collection, Action<T> arg_action)
        {
            Probe(() => Assert.All<T>(arg_collection, arg_action));
        }

        public void All<T>(IAsyncEnumerable<T> arg_collection, Action<T, System.Int32> arg_action)
        {
            Probe(() => Assert.All<T>(arg_collection, arg_action));
        }

        public void Collection<T>(IAsyncEnumerable<T> arg_collection, Action<T>[] arg_elementInspectors)
        {
            Probe(() => Assert.Collection<T>(arg_collection, arg_elementInspectors));
        }

        public void Contains<T>(T arg_expected, IAsyncEnumerable<T> arg_collection)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_collection));
        }

        public void Contains<T>(T arg_expected, IAsyncEnumerable<T> arg_collection, IEqualityComparer<T> arg_comparer)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_collection, arg_comparer));
        }

        public void Contains<T>(IAsyncEnumerable<T> arg_collection, Predicate<T> arg_filter)
        {
            Probe(() => Assert.Contains<T>(arg_collection, arg_filter));
        }

        public void Distinct<T>(IAsyncEnumerable<T> arg_collection)
        {
            Probe(() => Assert.Distinct<T>(arg_collection));
        }

        public void Distinct<T>(IAsyncEnumerable<T> arg_collection, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.Distinct<T>(arg_collection, arg_comparer));
        }

        public void DoesNotContain<T>(T arg_expected, IAsyncEnumerable<T> arg_collection)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_collection));
        }

        public void DoesNotContain<T>(T arg_expected, IAsyncEnumerable<T> arg_collection, IEqualityComparer<T> arg_comparer)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_collection, arg_comparer));
        }

        public void DoesNotContain<T>(IAsyncEnumerable<T> arg_collection, Predicate<T> arg_filter)
        {
            Probe(() => Assert.DoesNotContain<T>(arg_collection, arg_filter));
        }

        public void Empty<T>(IAsyncEnumerable<T> arg_collection)
        {
            Probe(() => Assert.Empty<T>(arg_collection));
        }

        public void Equal<T>(IEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual));
        }

        public void Equal<T>(IAsyncEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual));
        }

        public void Equal<T>(IEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void Equal<T>(IAsyncEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void Equal<T>(IEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual, Func<T, T, System.Boolean> arg_comparer)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void Equal<T>(IAsyncEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual, Func<T, T, System.Boolean> arg_comparer)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void NotEmpty<T>(IAsyncEnumerable<T> arg_collection)
        {
            Probe(() => Assert.NotEmpty<T>(arg_collection));
        }

        public void NotEqual<T>(IEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual));
        }

        public void NotEqual<T>(IAsyncEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual));
        }

        public void NotEqual<T>(IEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void NotEqual<T>(IAsyncEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void NotEqual<T>(IEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual, Func<T, T, System.Boolean> arg_comparer)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void NotEqual<T>(IAsyncEnumerable<T> arg_expected, IAsyncEnumerable<T> arg_actual, Func<T, T, System.Boolean> arg_comparer)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void False(System.Boolean arg_condition)
        {
            Probe(() => Assert.False(arg_condition));
        }

        public void False(Nullable<System.Boolean> arg_condition)
        {
            Probe(() => Assert.False(arg_condition));
        }

        public void False(System.Boolean arg_condition, System.String arg_userMessage)
        {
            Probe(() => Assert.False(arg_condition, arg_userMessage));
        }

        public void False(Nullable<System.Boolean> arg_condition, System.String arg_userMessage)
        {
            Probe(() => Assert.False(arg_condition, arg_userMessage));
        }

        public void True(System.Boolean arg_condition)
        {
            Probe(() => Assert.True(arg_condition));
        }

        public void True(Nullable<System.Boolean> arg_condition)
        {
            Probe(() => Assert.True(arg_condition));
        }

        public void True(System.Boolean arg_condition, System.String arg_userMessage)
        {
            Probe(() => Assert.True(arg_condition, arg_userMessage));
        }

        public void True(Nullable<System.Boolean> arg_condition, System.String arg_userMessage)
        {
            Probe(() => Assert.True(arg_condition, arg_userMessage));
        }

        public void All<T>(IEnumerable<T> arg_collection, Action<T> arg_action)
        {
            Probe(() => Assert.All<T>(arg_collection, arg_action));
        }

        public void All<T>(IEnumerable<T> arg_collection, Action<T, System.Int32> arg_action)
        {
            Probe(() => Assert.All<T>(arg_collection, arg_action));
        }

        public void Collection<T>(IEnumerable<T> arg_collection, Action<T>[] arg_elementInspectors)
        {
            Probe(() => Assert.Collection<T>(arg_collection, arg_elementInspectors));
        }

        public void Contains<T>(T arg_expected, IEnumerable<T> arg_collection)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_collection));
        }

        public void Contains<T>(T arg_expected, IEnumerable<T> arg_collection, IEqualityComparer<T> arg_comparer)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_collection, arg_comparer));
        }

        public void Contains<T>(IEnumerable<T> arg_collection, Predicate<T> arg_filter)
        {
            Probe(() => Assert.Contains<T>(arg_collection, arg_filter));
        }

        public void Distinct<T>(IEnumerable<T> arg_collection)
        {
            Probe(() => Assert.Distinct<T>(arg_collection));
        }

        public void Distinct<T>(IEnumerable<T> arg_collection, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.Distinct<T>(arg_collection, arg_comparer));
        }

        public void DoesNotContain<T>(T arg_expected, IEnumerable<T> arg_collection)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_collection));
        }

        public void DoesNotContain<T>(T arg_expected, IEnumerable<T> arg_collection, IEqualityComparer<T> arg_comparer)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_collection, arg_comparer));
        }

        public void DoesNotContain<T>(IEnumerable<T> arg_collection, Predicate<T> arg_filter)
        {
            Probe(() => Assert.DoesNotContain<T>(arg_collection, arg_filter));
        }

        public void Empty(System.Collections.IEnumerable arg_collection)
        {
            Probe(() => Assert.Empty(arg_collection));
        }

        public void Equal<T>(IEnumerable<T> arg_expected, IEnumerable<T> arg_actual)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual));
        }

        public void Equal<T>(IEnumerable<T> arg_expected, IEnumerable<T> arg_actual, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void Equal<T>(IEnumerable<T> arg_expected, IEnumerable<T> arg_actual, Func<T, T, System.Boolean> arg_comparer)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void NotEmpty(System.Collections.IEnumerable arg_collection)
        {
            Probe(() => Assert.NotEmpty(arg_collection));
        }

        public void NotEqual<T>(IEnumerable<T> arg_expected, IEnumerable<T> arg_actual)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual));
        }

        public void NotEqual<T>(IEnumerable<T> arg_expected, IEnumerable<T> arg_actual, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void NotEqual<T>(IEnumerable<T> arg_expected, IEnumerable<T> arg_actual, Func<T, T, System.Boolean> arg_comparer)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void Single(System.Collections.IEnumerable arg_collection, System.Object arg_expected)
        {
            Probe(() => Assert.Single(arg_collection, arg_expected));
        }

        public void DoesNotContain<TKey, TValue>(TKey arg_expected, IDictionary<TKey, TValue> arg_collection)
        where TKey : notnull
        {
            Probe(() => Assert.DoesNotContain<TKey, TValue>(arg_expected, arg_collection));
        }

        public void DoesNotContain<TKey, TValue>(TKey arg_expected, IReadOnlyDictionary<TKey, TValue> arg_collection)
        where TKey : notnull
        {
            Probe(() => Assert.DoesNotContain<TKey, TValue>(arg_expected, arg_collection));
        }

        public void DoesNotContain<TKey, TValue>(TKey arg_expected, ConcurrentDictionary<TKey, TValue> arg_collection)
        where TKey : notnull
        {
            Probe(() => Assert.DoesNotContain<TKey, TValue>(arg_expected, arg_collection));
        }

        public void DoesNotContain<TKey, TValue>(TKey arg_expected, Dictionary<TKey, TValue> arg_collection)
        where TKey : notnull
        {
            Probe(() => Assert.DoesNotContain<TKey, TValue>(arg_expected, arg_collection));
        }

        public void DoesNotContain<TKey, TValue>(TKey arg_expected, ReadOnlyDictionary<TKey, TValue> arg_collection)
        where TKey : notnull
        {
            Probe(() => Assert.DoesNotContain<TKey, TValue>(arg_expected, arg_collection));
        }

        public void DoesNotContain<TKey, TValue>(TKey arg_expected, ImmutableDictionary<TKey, TValue> arg_collection)
        where TKey : notnull
        {
            Probe(() => Assert.DoesNotContain<TKey, TValue>(arg_expected, arg_collection));
        }

        public void Equal<T>([AllowNull] T[] arg_expected, [AllowNull] T[] arg_actual)
        where T : struct
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual));
        }

        public void Equal<T>([AllowNull] T arg_expected, [AllowNull] T arg_actual)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual));
        }

        public void Equal<T>([AllowNull] T arg_expected, [AllowNull] T arg_actual, Func<T, T, System.Boolean> arg_comparer)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void Equal<T>([AllowNull] T arg_expected, [AllowNull] T arg_actual, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.Equal<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void Equal(System.Double arg_expected, System.Double arg_actual, System.Int32 arg_precision)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_precision));
        }

        public void Equal(System.Double arg_expected, System.Double arg_actual, System.Int32 arg_precision, System.MidpointRounding arg_rounding)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_precision, arg_rounding));
        }

        public void Equal(System.Double arg_expected, System.Double arg_actual, System.Double arg_tolerance)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_tolerance));
        }

        public void Equal(System.Single arg_expected, System.Single arg_actual, System.Int32 arg_precision)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_precision));
        }

        public void Equal(System.Single arg_expected, System.Single arg_actual, System.Int32 arg_precision, System.MidpointRounding arg_rounding)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_precision, arg_rounding));
        }

        public void Equal(System.Single arg_expected, System.Single arg_actual, System.Single arg_tolerance)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_tolerance));
        }

        public void Equal(System.Decimal arg_expected, System.Decimal arg_actual, System.Int32 arg_precision)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_precision));
        }

        public void Equal(System.DateTime arg_expected, System.DateTime arg_actual)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual));
        }

        public void Equal(System.DateTime arg_expected, System.DateTime arg_actual, System.TimeSpan arg_precision)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_precision));
        }

        public void Equal(System.DateTimeOffset arg_expected, System.DateTimeOffset arg_actual)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual));
        }

        public void Equal(System.DateTimeOffset arg_expected, System.DateTimeOffset arg_actual, System.TimeSpan arg_precision)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_precision));
        }

        public void NotEqual<T>([AllowNull] T[] arg_expected, [AllowNull] T[] arg_actual)
        where T : struct
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual));
        }

        public void NotEqual<T>([AllowNull] T arg_expected, [AllowNull] T arg_actual)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual));
        }

        public void NotEqual<T>([AllowNull] T arg_expected, [AllowNull] T arg_actual, Func<T, T, System.Boolean> arg_comparer)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void NotEqual<T>([AllowNull] T arg_expected, [AllowNull] T arg_actual, IEqualityComparer<T> arg_comparer)
        {
            Probe(() => Assert.NotEqual<T>(arg_expected, arg_actual, arg_comparer));
        }

        public void NotEqual(System.Double arg_expected, System.Double arg_actual, System.Int32 arg_precision)
        {
            Probe(() => Assert.NotEqual(arg_expected, arg_actual, arg_precision));
        }

        public void NotEqual(System.Double arg_expected, System.Double arg_actual, System.Int32 arg_precision, System.MidpointRounding arg_rounding)
        {
            Probe(() => Assert.NotEqual(arg_expected, arg_actual, arg_precision, arg_rounding));
        }

        public void NotEqual(System.Double arg_expected, System.Double arg_actual, System.Double arg_tolerance)
        {
            Probe(() => Assert.NotEqual(arg_expected, arg_actual, arg_tolerance));
        }

        public void NotEqual(System.Single arg_expected, System.Single arg_actual, System.Int32 arg_precision)
        {
            Probe(() => Assert.NotEqual(arg_expected, arg_actual, arg_precision));
        }

        public void NotEqual(System.Single arg_expected, System.Single arg_actual, System.Int32 arg_precision, System.MidpointRounding arg_rounding)
        {
            Probe(() => Assert.NotEqual(arg_expected, arg_actual, arg_precision, arg_rounding));
        }

        public void NotEqual(System.Single arg_expected, System.Single arg_actual, System.Single arg_tolerance)
        {
            Probe(() => Assert.NotEqual(arg_expected, arg_actual, arg_tolerance));
        }

        public void NotEqual(System.Decimal arg_expected, System.Decimal arg_actual, System.Int32 arg_precision)
        {
            Probe(() => Assert.NotEqual(arg_expected, arg_actual, arg_precision));
        }

        public void NotStrictEqual<T>([AllowNull] T arg_expected, [AllowNull] T arg_actual)
        {
            Probe(() => Assert.NotStrictEqual<T>(arg_expected, arg_actual));
        }

        public void StrictEqual<T>([AllowNull] T arg_expected, [AllowNull] T arg_actual)
        {
            Probe(() => Assert.StrictEqual<T>(arg_expected, arg_actual));
        }

        public void Equivalent(System.Object arg_expected, System.Object arg_actual, System.Boolean arg_strict)
        {
            Probe(() => Assert.Equivalent(arg_expected, arg_actual, arg_strict));
        }

        public void Raises(Action<System.Action> arg_attach, Action<System.Action> arg_detach, System.Action arg_testCode)
        {
            Probe(() => Assert.Raises(arg_attach, arg_detach, arg_testCode));
        }

        public void Fail(System.String arg_message)
        {
            Probe(() => Assert.Fail(arg_message));
        }

        public void NotSame(System.Object arg_expected, System.Object arg_actual)
        {
            Probe(() => Assert.NotSame(arg_expected, arg_actual));
        }

        public void Same(System.Object arg_expected, System.Object arg_actual)
        {
            Probe(() => Assert.Same(arg_expected, arg_actual));
        }

        public void Contains<T>(Memory<T> arg_expectedSubMemory, Memory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.Contains<T>(arg_expectedSubMemory, arg_actualMemory));
        }

        public void Contains<T>(Memory<T> arg_expectedSubMemory, ReadOnlyMemory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.Contains<T>(arg_expectedSubMemory, arg_actualMemory));
        }

        public void Contains<T>(ReadOnlyMemory<T> arg_expectedSubMemory, Memory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.Contains<T>(arg_expectedSubMemory, arg_actualMemory));
        }

        public void Contains<T>(ReadOnlyMemory<T> arg_expectedSubMemory, ReadOnlyMemory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.Contains<T>(arg_expectedSubMemory, arg_actualMemory));
        }

        public void DoesNotContain<T>(Memory<T> arg_expectedSubMemory, Memory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expectedSubMemory, arg_actualMemory));
        }

        public void DoesNotContain<T>(Memory<T> arg_expectedSubMemory, ReadOnlyMemory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expectedSubMemory, arg_actualMemory));
        }

        public void DoesNotContain<T>(ReadOnlyMemory<T> arg_expectedSubMemory, Memory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expectedSubMemory, arg_actualMemory));
        }

        public void DoesNotContain<T>(ReadOnlyMemory<T> arg_expectedSubMemory, ReadOnlyMemory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expectedSubMemory, arg_actualMemory));
        }

        public void Equal<T>(Memory<T> arg_expectedMemory, Memory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.Equal<T>(arg_expectedMemory, arg_actualMemory));
        }

        public void Equal<T>(Memory<T> arg_expectedMemory, ReadOnlyMemory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.Equal<T>(arg_expectedMemory, arg_actualMemory));
        }

        public void Equal<T>(ReadOnlyMemory<T> arg_expectedMemory, Memory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.Equal<T>(arg_expectedMemory, arg_actualMemory));
        }

        public void Equal<T>(ReadOnlyMemory<T> arg_expectedMemory, ReadOnlyMemory<T> arg_actualMemory)
        where T : IEquatable<T>
        {
            Probe(() => Assert.Equal<T>(arg_expectedMemory, arg_actualMemory));
        }

        public void Multiple(System.Action[] arg_checks)
        {
            Probe(() => Assert.Multiple(arg_checks));
        }

        public void NotNull(System.Object arg_object)
        {
            Probe(() => Assert.NotNull(arg_object));
        }

        public void Null(System.Object arg_object)
        {
            Probe(() => Assert.Null(arg_object));
        }

        public void Null<T>(Nullable<T> arg_value)
        where T : struct
        {
            Probe(() => Assert.Null<T>(arg_value));
        }

        public void PropertyChanged(System.ComponentModel.INotifyPropertyChanged arg_object, System.String arg_propertyName, System.Action arg_testCode)
        {
            Probe(() => Assert.PropertyChanged(arg_object, arg_propertyName, arg_testCode));
        }

        public void InRange<T>(T arg_actual, T arg_low, T arg_high)
        where T : notnull, System.IComparable
        {
            Probe(() => Assert.InRange<T>(arg_actual, arg_low, arg_high));
        }

        public void InRange<T>(T arg_actual, T arg_low, T arg_high, IComparer<T> arg_comparer)
        where T : notnull
        {
            Probe(() => Assert.InRange<T>(arg_actual, arg_low, arg_high, arg_comparer));
        }

        public void NotInRange<T>(T arg_actual, T arg_low, T arg_high)
        where T : notnull, System.IComparable
        {
            Probe(() => Assert.NotInRange<T>(arg_actual, arg_low, arg_high));
        }

        public void NotInRange<T>(T arg_actual, T arg_low, T arg_high, IComparer<T> arg_comparer)
        where T : notnull
        {
            Probe(() => Assert.NotInRange<T>(arg_actual, arg_low, arg_high, arg_comparer));
        }

        public void Contains<T>(T arg_expected, ISet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_set));
        }

        public void Contains<T>(T arg_expected, IReadOnlySet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_set));
        }

        public void Contains<T>(T arg_expected, HashSet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_set));
        }

        public void Contains<T>(T arg_expected, SortedSet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_set));
        }

        public void Contains<T>(T arg_expected, ImmutableHashSet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_set));
        }

        public void Contains<T>(T arg_expected, ImmutableSortedSet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.Contains<T>(arg_expected, arg_set));
        }

        public void DoesNotContain<T>(T arg_expected, ISet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_set));
        }

        public void DoesNotContain<T>(T arg_expected, IReadOnlySet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_set));
        }

        public void DoesNotContain<T>(T arg_expected, HashSet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_set));
        }

        public void DoesNotContain<T>(T arg_expected, SortedSet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_set));
        }

        public void DoesNotContain<T>(T arg_expected, ImmutableHashSet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_set));
        }

        public void DoesNotContain<T>(T arg_expected, ImmutableSortedSet<T> arg_set)
        where T : notnull
        {
            Probe(() => Assert.DoesNotContain<T>(arg_expected, arg_set));
        }

        public void ProperSubset<T>(ISet<T> arg_expectedSubset, ISet<T> arg_actual)
        {
            Probe(() => Assert.ProperSubset<T>(arg_expectedSubset, arg_actual));
        }

        public void ProperSuperset<T>(ISet<T> arg_expectedSuperset, ISet<T> arg_actual)
        {
            Probe(() => Assert.ProperSuperset<T>(arg_expectedSuperset, arg_actual));
        }

        public void Subset<T>(ISet<T> arg_expectedSubset, ISet<T> arg_actual)
        {
            Probe(() => Assert.Subset<T>(arg_expectedSubset, arg_actual));
        }

        public void Superset<T>(ISet<T> arg_expectedSuperset, ISet<T> arg_actual)
        {
            Probe(() => Assert.Superset<T>(arg_expectedSuperset, arg_actual));
        }

        public void Contains(System.String arg_expectedSubstring, System.String arg_actualString)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString));
        }

        public void Contains(System.String arg_expectedSubstring, System.String arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void Contains(Memory<System.Char> arg_expectedSubstring, Memory<System.Char> arg_actualString)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString));
        }

        public void Contains(Memory<System.Char> arg_expectedSubstring, ReadOnlyMemory<System.Char> arg_actualString)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString));
        }

        public void Contains(ReadOnlyMemory<System.Char> arg_expectedSubstring, Memory<System.Char> arg_actualString)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString));
        }

        public void Contains(ReadOnlyMemory<System.Char> arg_expectedSubstring, ReadOnlyMemory<System.Char> arg_actualString)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString));
        }

        public void Contains(Memory<System.Char> arg_expectedSubstring, Memory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void Contains(Memory<System.Char> arg_expectedSubstring, ReadOnlyMemory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void Contains(ReadOnlyMemory<System.Char> arg_expectedSubstring, Memory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void Contains(ReadOnlyMemory<System.Char> arg_expectedSubstring, ReadOnlyMemory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.Contains(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void DoesNotContain(System.String arg_expectedSubstring, System.String arg_actualString)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString));
        }

        public void DoesNotContain(System.String arg_expectedSubstring, System.String arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void DoesNotContain(Memory<System.Char> arg_expectedSubstring, Memory<System.Char> arg_actualString)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString));
        }

        public void DoesNotContain(Memory<System.Char> arg_expectedSubstring, ReadOnlyMemory<System.Char> arg_actualString)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString));
        }

        public void DoesNotContain(ReadOnlyMemory<System.Char> arg_expectedSubstring, Memory<System.Char> arg_actualString)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString));
        }

        public void DoesNotContain(ReadOnlyMemory<System.Char> arg_expectedSubstring, ReadOnlyMemory<System.Char> arg_actualString)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString));
        }

        public void DoesNotContain(Memory<System.Char> arg_expectedSubstring, Memory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void DoesNotContain(Memory<System.Char> arg_expectedSubstring, ReadOnlyMemory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void DoesNotContain(ReadOnlyMemory<System.Char> arg_expectedSubstring, Memory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void DoesNotContain(ReadOnlyMemory<System.Char> arg_expectedSubstring, ReadOnlyMemory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.DoesNotContain(arg_expectedSubstring, arg_actualString, arg_comparisonType));
        }

        public void DoesNotMatch(System.String arg_expectedRegexPattern, System.String arg_actualString)
        {
            Probe(() => Assert.DoesNotMatch(arg_expectedRegexPattern, arg_actualString));
        }

        public void DoesNotMatch(System.Text.RegularExpressions.Regex arg_expectedRegex, System.String arg_actualString)
        {
            Probe(() => Assert.DoesNotMatch(arg_expectedRegex, arg_actualString));
        }

        public void Empty(System.String arg_value)
        {
            Probe(() => Assert.Empty(arg_value));
        }

        public void EndsWith(System.String arg_expectedEndString, System.String arg_actualString)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString));
        }

        public void EndsWith(System.String arg_expectedEndString, System.String arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString, arg_comparisonType));
        }

        public void EndsWith(Memory<System.Char> arg_expectedEndString, Memory<System.Char> arg_actualString)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString));
        }

        public void EndsWith(Memory<System.Char> arg_expectedEndString, ReadOnlyMemory<System.Char> arg_actualString)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString));
        }

        public void EndsWith(ReadOnlyMemory<System.Char> arg_expectedEndString, Memory<System.Char> arg_actualString)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString));
        }

        public void EndsWith(ReadOnlyMemory<System.Char> arg_expectedEndString, ReadOnlyMemory<System.Char> arg_actualString)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString));
        }

        public void EndsWith(Memory<System.Char> arg_expectedEndString, Memory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString, arg_comparisonType));
        }

        public void EndsWith(Memory<System.Char> arg_expectedEndString, ReadOnlyMemory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString, arg_comparisonType));
        }

        public void EndsWith(ReadOnlyMemory<System.Char> arg_expectedEndString, Memory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString, arg_comparisonType));
        }

        public void EndsWith(ReadOnlyMemory<System.Char> arg_expectedEndString, ReadOnlyMemory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.EndsWith(arg_expectedEndString, arg_actualString, arg_comparisonType));
        }

        public void Equal(System.String arg_expected, System.String arg_actual)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual));
        }

        public void Equal(Memory<System.Char> arg_expected, Memory<System.Char> arg_actual)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual));
        }

        public void Equal(Memory<System.Char> arg_expected, ReadOnlyMemory<System.Char> arg_actual)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual));
        }

        public void Equal(ReadOnlyMemory<System.Char> arg_expected, Memory<System.Char> arg_actual)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual));
        }

        public void Equal(ReadOnlyMemory<System.Char> arg_expected, ReadOnlyMemory<System.Char> arg_actual)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual));
        }

        public void Equal(Memory<System.Char> arg_expected, Memory<System.Char> arg_actual, System.Boolean arg_ignoreCase, System.Boolean arg_ignoreLineEndingDifferences, System.Boolean arg_ignoreWhiteSpaceDifferences, System.Boolean arg_ignoreAllWhiteSpace)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_ignoreCase, arg_ignoreLineEndingDifferences, arg_ignoreWhiteSpaceDifferences, arg_ignoreAllWhiteSpace));
        }

        public void Equal(Memory<System.Char> arg_expected, ReadOnlyMemory<System.Char> arg_actual, System.Boolean arg_ignoreCase, System.Boolean arg_ignoreLineEndingDifferences, System.Boolean arg_ignoreWhiteSpaceDifferences, System.Boolean arg_ignoreAllWhiteSpace)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_ignoreCase, arg_ignoreLineEndingDifferences, arg_ignoreWhiteSpaceDifferences, arg_ignoreAllWhiteSpace));
        }

        public void Equal(ReadOnlyMemory<System.Char> arg_expected, Memory<System.Char> arg_actual, System.Boolean arg_ignoreCase, System.Boolean arg_ignoreLineEndingDifferences, System.Boolean arg_ignoreWhiteSpaceDifferences, System.Boolean arg_ignoreAllWhiteSpace)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_ignoreCase, arg_ignoreLineEndingDifferences, arg_ignoreWhiteSpaceDifferences, arg_ignoreAllWhiteSpace));
        }

        public void Equal(ReadOnlyMemory<System.Char> arg_expected, ReadOnlyMemory<System.Char> arg_actual, System.Boolean arg_ignoreCase, System.Boolean arg_ignoreLineEndingDifferences, System.Boolean arg_ignoreWhiteSpaceDifferences, System.Boolean arg_ignoreAllWhiteSpace)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_ignoreCase, arg_ignoreLineEndingDifferences, arg_ignoreWhiteSpaceDifferences, arg_ignoreAllWhiteSpace));
        }

        public void Equal(System.String arg_expected, System.String arg_actual, System.Boolean arg_ignoreCase, System.Boolean arg_ignoreLineEndingDifferences, System.Boolean arg_ignoreWhiteSpaceDifferences, System.Boolean arg_ignoreAllWhiteSpace)
        {
            Probe(() => Assert.Equal(arg_expected, arg_actual, arg_ignoreCase, arg_ignoreLineEndingDifferences, arg_ignoreWhiteSpaceDifferences, arg_ignoreAllWhiteSpace));
        }

        public void Matches(System.String arg_expectedRegexPattern, System.String arg_actualString)
        {
            Probe(() => Assert.Matches(arg_expectedRegexPattern, arg_actualString));
        }

        public void Matches(System.Text.RegularExpressions.Regex arg_expectedRegex, System.String arg_actualString)
        {
            Probe(() => Assert.Matches(arg_expectedRegex, arg_actualString));
        }

        public void StartsWith(System.String arg_expectedStartString, System.String arg_actualString)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString));
        }

        public void StartsWith(System.String arg_expectedStartString, System.String arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString, arg_comparisonType));
        }

        public void StartsWith(Memory<System.Char> arg_expectedStartString, Memory<System.Char> arg_actualString)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString));
        }

        public void StartsWith(Memory<System.Char> arg_expectedStartString, ReadOnlyMemory<System.Char> arg_actualString)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString));
        }

        public void StartsWith(ReadOnlyMemory<System.Char> arg_expectedStartString, Memory<System.Char> arg_actualString)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString));
        }

        public void StartsWith(ReadOnlyMemory<System.Char> arg_expectedStartString, ReadOnlyMemory<System.Char> arg_actualString)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString));
        }

        public void StartsWith(Memory<System.Char> arg_expectedStartString, Memory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString, arg_comparisonType));
        }

        public void StartsWith(Memory<System.Char> arg_expectedStartString, ReadOnlyMemory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString, arg_comparisonType));
        }

        public void StartsWith(ReadOnlyMemory<System.Char> arg_expectedStartString, Memory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString, arg_comparisonType));
        }

        public void StartsWith(ReadOnlyMemory<System.Char> arg_expectedStartString, ReadOnlyMemory<System.Char> arg_actualString, System.StringComparison arg_comparisonType)
        {
            Probe(() => Assert.StartsWith(arg_expectedStartString, arg_actualString, arg_comparisonType));
        }

        public void IsAssignableFrom(System.Type arg_expectedType, System.Object arg_object)
        {
            Probe(() => Assert.IsAssignableFrom(arg_expectedType, arg_object));
        }

        public void IsNotAssignableFrom<T>(System.Object arg_object)
        {
            Probe(() => Assert.IsNotAssignableFrom<T>(arg_object));
        }

        public void IsNotAssignableFrom(System.Type arg_expectedType, System.Object arg_object)
        {
            Probe(() => Assert.IsNotAssignableFrom(arg_expectedType, arg_object));
        }

        public void IsNotType<T>(System.Object arg_object)
        {
            Probe(() => Assert.IsNotType<T>(arg_object));
        }

        public void IsNotType<T>(System.Object arg_object, System.Boolean arg_exactMatch)
        {
            Probe(() => Assert.IsNotType<T>(arg_object, arg_exactMatch));
        }

        public void IsNotType(System.Type arg_expectedType, System.Object arg_object)
        {
            Probe(() => Assert.IsNotType(arg_expectedType, arg_object));
        }

        public void IsNotType(System.Type arg_expectedType, System.Object arg_object, System.Boolean arg_exactMatch)
        {
            Probe(() => Assert.IsNotType(arg_expectedType, arg_object, arg_exactMatch));
        }

        public void IsType(System.Type arg_expectedType, System.Object arg_object)
        {
            Probe(() => Assert.IsType(arg_expectedType, arg_object));
        }

        public void IsType(System.Type arg_expectedType, System.Object arg_object, System.Boolean arg_exactMatch)
        {
            Probe(() => Assert.IsType(arg_expectedType, arg_object, arg_exactMatch));
        }
    }
}